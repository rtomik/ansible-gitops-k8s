- name: Get git api token
  block:
    - name: Get Gitea API token from secret
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Secret
        name: gitea-api-token
        namespace: argocd
      register: gitea_token_secret

    - name: Set API token fact
      ansible.builtin.set_fact:
        gitea_api_token: "{{ gitea_token_secret.resources[0].data.api_token | b64decode }}"
      no_log: true
      when: gitea_token_secret.resources is defined and gitea_token_secret.resources | length > 0

    - name: Verify API token was retrieved
      ansible.builtin.fail:
        msg: "Failed to retrieve Gitea API token from Kubernetes secret"
      when: gitea_api_token is not defined or gitea_api_token | length == 0

# for some reason env from secret didnt worked for renovate helm chart
- name: Get git renovate api key
  when: deploy_renovate | bool and deploy_gitea | bool
  block:
    - name: Read back the Gitea API token from the k8s Secret
      kubernetes.core.k8s_info:
        kind: Secret
        namespace: renovate
        name: gitea-api-token
      register: secret_info

    - name: Decode it into a variable and remove trailing newline
      ansible.builtin.set_fact:
        renovate_api_token: >-
          {{ secret_info.resources[0].data.api_token | b64decode | regex_replace('\\n$', '') }}

- name: Deploy infrastructure apps via ArgoCD
  block:
    - name: Display enabled apps for deployment
      ansible.builtin.debug:
        msg: "Deploying the following apps: {{ enabled_apps | map(attribute='key') | join(', ') }}"

    - name: Create temporary directory for Git operations
      ansible.builtin.tempfile:
        state: directory
        suffix: -gitops
      register: git_temp_dir

    - name: Clone Git repository
      ansible.builtin.git:
        repo: "https://admin:{{ gitea_api_token | urlencode }}@git.{{ domain }}/{{ git_organization_name }}/{{ git_repo_name }}.git"
        dest: "{{ git_temp_dir.path }}"
        force: true
      environment:
        GIT_SSL_NO_VERIFY: "true"
        GIT_TERMINAL_PROMPT: "0"

    - name: Create directory structure
      ansible.builtin.file:
        path: "{{ git_temp_dir.path }}/{{ item }}"
        state: directory
      loop: "{{ directories }}"

    - name: Create Chart.yaml files
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/apps/{{ item.key }}/Chart.yaml"
        content: |
          apiVersion: v2
          name: {{ item.key }}
          description: Helm chart for {{ item.key }}
          type: application
          version: 0.0.0
          dependencies:
            - name: {{ item.value.chart_name }}
              version: {{ item.value.version }}
              repository: {{ item.value.repo }}
      loop: "{{ enabled_apps }}"
      when: item.value.source_type is not defined or item.value.source_type != 'directory'

    - name: Create values.yaml files
      ansible.builtin.template:
        src: "values-{{ item.key }}.yml.j2"
        dest: "{{ git_temp_dir.path }}/apps/{{ item.key }}/values.yaml"
      loop: "{{ enabled_apps }}"
      when: item.value.source_type is not defined or item.value.source_type != 'directory'

    - name: Create PostgreSQL cluster manifest from group_vars
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/pg-clusters/{{ postgresql.cluster_name }}.yaml"
        content: |
          apiVersion: postgresql.cnpg.io/v1
          kind: Cluster
          metadata:
            name: {{ postgresql.cluster_name }}
            namespace: {{ postgresql.namespace }}
          spec:
            description: "Main PostgreSQL Cluster - managed by GitOps"
            instances: {{ postgresql.instances }}

            postgresql:
              parameters:
                max_connections: "{{ postgresql.config.max_connections }}"
                shared_buffers: "{{ postgresql.config.shared_buffers }}"
                effective_cache_size: "{{ postgresql.config.effective_cache_size }}"
                maintenance_work_mem: "{{ postgresql.config.maintenance_work_mem }}"

            bootstrap:
              initdb:
                database: {{ postgresql.default_database }}
                owner: {{ postgresql.app_user }}
                secret:
                  name: {{ postgresql.cluster_name }}-app

            superuserSecret:
              name: {{ postgresql.cluster_name }}-superuser

            storage:
              size: "{{ postgresql.storage.size }}"
              storageClass: "{{ postgresql.storage.storage_class }}"

            monitoring:
              enabled: true
              enablePodMonitor: true
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ postgresql.cluster_name }}-superuser
            namespace: {{ postgresql.namespace }}
          type: kubernetes.io/basic-auth
          data:
            username: {{ 'postgres' | b64encode }}
            password: {{ postgresql.superuser_password | b64encode }}
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ postgresql.cluster_name }}-app
            namespace: {{ postgresql.namespace }}
          type: kubernetes.io/basic-auth
          data:
            username: {{ postgresql.app_user | b64encode }}
            password: {{ postgresql.app_password | b64encode }}
        mode: '0644'
      when: deploy_cnpg | bool and postgresql.enabled | bool

    - name: Create PostgreSQL pooler manifest from group_vars
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/pg-clusters/{{ postgresql.cluster_name }}-pooler.yaml"
        content: |
          apiVersion: postgresql.cnpg.io/v1
          kind: Pooler
          metadata:
            name: {{ postgresql.cluster_name }}-pooler
            namespace: {{ postgresql.namespace }}
          spec:
            cluster:
              name: {{ postgresql.cluster_name }}
            instances: {{ postgresql.pooler.instances }}
            type: rw
            pgbouncer:
              poolMode: "{{ postgresql.pooler.pool_mode }}"
              parameters:
                max_client_conn: "{{ postgresql.pooler.max_client_conn }}"
                default_pool_size: "{{ postgresql.pooler.default_pool_size }}"
                min_pool_size: "{{ postgresql.pooler.min_pool_size }}"
                reserve_pool_size: "{{ postgresql.pooler.reserve_pool_size }}"
                server_lifetime: "{{ postgresql.pooler.server_lifetime }}"
                server_idle_timeout: "{{ postgresql.pooler.server_idle_timeout }}"
        mode: '0644'
      when: deploy_cnpg | bool and postgresql.enabled | bool and postgresql.pooler.enabled | bool

    - name: Create application databases manifests
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/pg-clusters/app-database-{{ item.key }}.yaml"
        content: |
          ---
          apiVersion: postgresql.cnpg.io/v1
          kind: Database
          metadata:
            name: {{ item.key }}-database
            namespace: {{ postgresql.namespace }}
          spec:
            name: {{ item.value.database_name }}
            cluster:
              name: {{ postgresql.cluster_name }}
            owner: {{ item.value.username }}
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ item.key }}-db-credentials
            namespace: {{ postgresql.namespace }}
            labels:
              app: {{ item.key }}
              component: database
          type: kubernetes.io/basic-auth
          data:
            username: {{ item.value.username | b64encode }}
            password: {{ item.value.password | b64encode }}
            database: {{ item.value.database_name | b64encode }}
            # Connection strings for applications
            connection_string: {{ ('postgresql://' + item.value.username + ':' + item.value.password + '@' + postgresql.cluster_name + '-pooler.' + postgresql.namespace + '.svc.cluster.local:5432/' + item.value.database_name) | b64encode }}
            connection_string_rw: {{ ('postgresql://' + item.value.username + ':' + item.value.password + '@' + postgresql.cluster_name + '-rw.' + postgresql.namespace + '.svc.cluster.local:5432/' + item.value.database_name) | b64encode }}
            connection_string_ro: {{ ('postgresql://' + item.value.username + ':' + item.value.password + '@' + postgresql.cluster_name + '-ro.' + postgresql.namespace + '.svc.cluster.local:5432/' + item.value.database_name) | b64encode }}
        mode: '0644'
      loop: "{{ postgresql.databases | dict2items | selectattr('value.enabled', 'boolean') | list }}"
      when: deploy_cnpg | bool and postgresql.enabled | bool and postgresql.databases is defined

    - name: Create database initialization job
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/pg-clusters/database-init-job.yaml"
        content: |
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: postgres-database-init
            namespace: {{ postgresql.namespace }}
            annotations:
              argocd.argoproj.io/hook: PostSync
              argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
          spec:
            ttlSecondsAfterFinished: 300
            template:
              spec:
                restartPolicy: OnFailure
                containers:
                - name: db-init
                  image: bitnami/kubectl:latest
                  command:
                  - /bin/bash
                  - -c
                  - |
                    set -e
                    echo "Initializing application databases..."
                    
                    # Install postgresql client
                    apt-get update && apt-get install -y postgresql-client-15 || \
                    apk add --no-cache postgresql15-client || \
                    echo "PostgreSQL client already available"
                    
                    # Wait for cluster to be ready
                    until kubectl get clusters.postgresql.cnpg.io {{ postgresql.cluster_name }} -n {{ postgresql.namespace }} -o jsonpath='{.status.phase}' | grep -q "Cluster in healthy state"; do
                      echo "Waiting for PostgreSQL cluster to be ready..."
                      sleep 5
                    done
                    
                    # Use kubectl exec to run commands directly on the primary pod
                    PRIMARY_POD=$(kubectl get pods -n {{ postgresql.namespace }} -l cnpg.io/cluster={{ postgresql.cluster_name }},role=primary -o jsonpath='{.items[0].metadata.name}')
                    echo "Using primary pod: $PRIMARY_POD"
                    
          {% for db_key, db_config in postgresql.databases.items() %}
          {% if db_config.enabled %}
                    echo "Creating database {{ db_config.database_name }} and user {{ db_config.username }}..."
                    
                    # Create user if not exists
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -c "DO \$\$ BEGIN IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '{{ db_config.username }}') THEN CREATE USER {{ db_config.username }} WITH PASSWORD '{{ db_config.password }}'; END IF; END \$\$;"
                    
                    # Create database if not exists
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -c "SELECT 1 FROM pg_database WHERE datname = '{{ db_config.database_name }}'" | grep -q 1 || kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -c "CREATE DATABASE {{ db_config.database_name }} OWNER {{ db_config.username }};"
                    
                    # Grant privileges
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "GRANT {{ db_config.privileges }} ON SCHEMA public TO {{ db_config.username }};"
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "GRANT {{ db_config.privileges }} ON ALL TABLES IN SCHEMA public TO {{ db_config.username }};"
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "GRANT {{ db_config.privileges }} ON ALL SEQUENCES IN SCHEMA public TO {{ db_config.username }};"
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT {{ db_config.privileges }} ON TABLES TO {{ db_config.username }};"
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT {{ db_config.privileges }} ON SEQUENCES TO {{ db_config.username }};"
                    
            {% if db_config.extensions %}
                    # Install extensions for {{ db_config.database_name }}
            {% for extension in db_config.extensions %}
                    kubectl exec $PRIMARY_POD -n {{ postgresql.namespace }} -- psql -U postgres -d {{ db_config.database_name }} -c "CREATE EXTENSION IF NOT EXISTS \"{{ extension }}\";"
            {% endfor %}
            {% endif %}
                    
                    echo "âœ… Database {{ db_config.database_name }} configured for user {{ db_config.username }}"
                    
          {% endif %}
          {% endfor %}
                    echo "ðŸŽ‰ All application databases initialized successfully!"
                serviceAccountName: postgres-db-init
          ---
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: postgres-db-init
            namespace: {{ postgresql.namespace }}
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: Role
          metadata:
            namespace: {{ postgresql.namespace }}
            name: postgres-db-init
          rules:
          - apiGroups: [""]
            resources: ["pods"]
            verbs: ["get", "list"]
          - apiGroups: [""]
            resources: ["pods/exec"]
            verbs: ["create"]
          - apiGroups: ["postgresql.cnpg.io"]
            resources: ["clusters"]
            verbs: ["get", "list"]
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: RoleBinding
          metadata:
            name: postgres-db-init
            namespace: {{ postgresql.namespace }}
          subjects:
          - kind: ServiceAccount
            name: postgres-db-init
            namespace: {{ postgresql.namespace }}
          roleRef:
            kind: Role
            name: postgres-db-init
            apiGroup: rbac.authorization.k8s.io
        mode: '0644'
      when: deploy_cnpg | bool and postgresql.enabled | bool and postgresql.databases is defined

    - name: Create PostgreSQL cluster README
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/pg-clusters/README.md"
        content: |
          # PostgreSQL Clusters - GitOps Management
          
          This directory contains PostgreSQL cluster and application database definitions managed by ArgoCD GitOps.
          
          ## Automated Application Databases
          
          Application databases are automatically created based on `group_vars/all/main.yml` configuration.
          Each application gets:
          - âœ… Dedicated database
          - âœ… Dedicated user with limited privileges
          - âœ… Kubernetes secret with connection details
          - âœ… Required PostgreSQL extensions
          
          ### Current Application Databases:
          {% for db_key, db_config in postgresql.databases.items() %}
          {% if db_config.enabled %}
          
          **{{ db_key | title }}**:
          - Database: `{{ db_config.database_name }}`
          - User: `{{ db_config.username }}`
          - Secret: `{{ db_key }}-db-credentials` (in namespace `{{ postgresql.namespace }}`)
          - Extensions: {{ db_config.extensions | join(', ') if db_config.extensions else 'None' }}
          {% endif %}
          {% endfor %}
          
          ### Adding New Application Database
          
          1. Edit `group_vars/all/main.yml`
          2. Add your app to `postgresql.databases`:
          
          ```yaml
          postgresql:
            databases:
              myapp:
                enabled: true
                database_name: "myapp"
                username: "myapp_user"
                password: ""
                description: "My application database"
                extensions:
                  - "uuid-ossp"  # Add required extensions
                privileges: "ALL"
          ```
          
          3. Add password to vault: `ansible-vault edit group_vars/all/vault.yml`
          4. Commit and push - ArgoCD will create the database automatically!
          
          ## Manual PostgreSQL Cluster Creation
          
          1. Create a new YAML file in this directory (e.g., `my-app-db.yaml`)
          2. Define your cluster specification following the CloudNativePG format
          3. Commit and push to Git - ArgoCD will automatically deploy your cluster
          
          ## Example Cluster Definition
          
          ```yaml
          apiVersion: postgresql.cnpg.io/v1
          kind: Cluster
          metadata:
            name: my-app-cluster
            namespace: dbs
          spec:
            description: "My Application Database"
            instances: 3  # High availability with 3 replicas
            
            postgresql:
              parameters:
                max_connections: "200"
                shared_buffers: "256MB"
                effective_cache_size: "1GB"
                maintenance_work_mem: "64MB"
            
            bootstrap:
              initdb:
                database: myapp
                owner: myapp_user
                secret:
                  name: my-app-cluster-app
            
            superuserSecret:
              name: my-app-cluster-superuser
            
            storage:
              size: "25Gi"
              storageClass: "longhorn"
            
            monitoring:
              enabled: true
              enablePodMonitor: true
          ---
          # Don't forget to create the secrets!
          apiVersion: v1
          kind: Secret
          metadata:
            name: my-app-cluster-superuser
            namespace: dbs
          type: kubernetes.io/basic-auth
          stringData:
            username: postgres
            password: your-super-secure-password
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: my-app-cluster-app
            namespace: dbs
          type: kubernetes.io/basic-auth
          stringData:
            username: myapp_user
            password: your-app-password
          ```
          
          ## Connection Information
          
          Once deployed, connect to your database using:
          - **Host**: `my-app-cluster-rw.dbs.svc.cluster.local` (read-write)
          - **Host**: `my-app-cluster-ro.dbs.svc.cluster.local` (read-only)
          - **Port**: `5432`
          - **Database**: As specified in your manifest
          - **Username/Password**: From your secrets
          
          ## Monitoring
          
          All clusters have monitoring enabled and metrics are scraped by Prometheus.
          View dashboards in Grafana under the PostgreSQL section.
          
          ## Best Practices
          
          1. Always use secrets for passwords (never hardcode)
          2. Use appropriate storage sizes for your workload
          3. Configure resource limits for production workloads
          4. Use multiple instances (3) for high availability
          5. Test backup/restore procedures regularly
        mode: '0644'
      when: deploy_cnpg | bool

    - name: Create ArgoCD applications
      ansible.builtin.copy:
        dest: "{{ git_temp_dir.path }}/argocd-apps/{{ item.key }}.yaml"
        content: |
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: {{ item.key }}
            namespace: argocd
          spec:
            project: default
            destination:
              server: https://kubernetes.default.svc
              namespace: {{ item.value.namespace }}
            source:
              repoURL: https://git.{{ domain }}/{{ git_organization_name }}/{{ git_repo_name }}.git
              targetRevision: HEAD
          {% if item.value.source_type is defined and item.value.source_type == 'directory' %}
              path: {{ item.value.path }}
          {% else %}
              path: apps/{{ item.key }}
              helm:
                valueFiles:
                  - values.yaml
          {% if item.value.skip_crds is defined and item.value.skip_crds | bool %}
                skipCrds: true
          {% endif %}
          {% endif %}
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
          {% if item.value.server_side is defined and item.value.server_side | bool %}
                - ServerSideApply=true
          {% endif %}
      loop: "{{ enabled_apps }}"

    - name: Push to Git repo
      ansible.builtin.shell: |
        cd {{ git_temp_dir.path }}
        git config user.email "ansible@{{ domain }}"
        git config user.name "Ansible Automation"
        git add .
        git diff --cached --quiet || git commit -m "Deploy enabled apps: {{ enabled_apps | map(attribute='key') | join(', ') }}"
        git push
      environment:
        GIT_TERMINAL_PROMPT: 0
        GIT_USERNAME: "admin"
        GIT_PASSWORD: "{{ gitea_api_token }}"
      register: git_push
      failed_when: git_push.rc != 0 and "No changes to commit" not in git_push.stdout

    - name: Apply ArgoCD applications
      kubernetes.core.k8s:
        state: present
        namespace: argocd
        src: "{{ git_temp_dir.path }}/argocd-apps/{{ item.key }}.yaml"
      loop: "{{ enabled_apps }}"
  always:
    - name: Remove temporary directory
      ansible.builtin.file:
        path: "{{ git_temp_dir.path }}"
        state: absent
      when: git_temp_dir.path is defined
